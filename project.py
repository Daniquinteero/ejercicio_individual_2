import math
import statistics

import matplotlib.pyplot as plt
import numpy as np

#   a) Transformar los datos en velocidades (vel_Lineal [m/s],
#       vel_Angular [rad/s], t [seg]), equivalentes a las que 
#       podrían obtenerse a partir de sensores inerciales 
#       instalados en la plataforma.


file = open('C:/Users/danie/Downloads/Path_SRA2223.txt','r')
content = file.readlines()
file.close()

dataset = []
for i in content:
    line = i[:-1]
    line = line.split(" ")
    line = [float(x) for x in line]
    dataset.append(line)


dataset_to_vel = []


dataset.pop()



last = dataset[0]

for i in dataset[1:]:

    temp = []

    # Calculate from the coordinates and time stamp to velocity in meters per second
    distance = (( i[0]  -  last[0])**2 + ( i[1]  -  last[1])**2)**0.5
    meters_per_second = distance / (i[2]-last[2])
    temp.append(meters_per_second)


    # Calculate from the coordinates and time stamp to angular velocity in radians per second
    angle_radians = math.atan2(i[1] - last[1], i[0] - last[0])
    radians_per_second = angle_radians / (i[2]-last[2])
    temp.append(radians_per_second)


    # Calculate difference in time stamps
    temp.append(i[2]-last[2])

    dataset_to_vel.append(temp)
    
    last = i




# RESULTADO:
#######################
#print(dataset_to_vel) #
#######################

#############################################################################################################


#   b) Extraer información que pudiera ser útil desde la 
#       perspectiva de un sistema robótico.


linear_displacement_x = []
linear_displacement_y = []
angular_displacement = []
linear_velocity_x = []
linear_velocity_y = []
average_linear_velocity_x = 0
average_linear_velocity_y = 0
average_angular_velocity = 0
total_displacement_linear = []

last = dataset[0]

for i in dataset[1:]:


    # Calculate linear displacement
    distance_x = i[0]-last[0]
    distance_y = i[1]-last[1]
    linear_displacement_x.append(distance_x)
    linear_displacement_y.append(distance_y)


    # Calculate angular displacement
    angle_radians = math.atan2(i[1] - last[1], i[0] - last[0])
    angular_displacement.append(angle_radians)


    # Calculate linear velocity
    time_dif = i[2]-last[2]
    meters_per_second_x = distance_x / time_dif
    linear_velocity_x.append(meters_per_second_x)

    meters_per_second_y = distance_y / time_dif
    linear_velocity_y.append(meters_per_second_y)

    # Calculate total linear displacement (Euclidean distance)
    total_displacement = (((i[0] - last[0])**2 + (i[1] - last[1]))**2)**0.5
    total_displacement_linear.append(total_displacement)


    last = i


# Calculate average linear velocity
average_linear_velocity_x = statistics.mean(linear_velocity_x)
average_linear_velocity_y = statistics.mean(linear_velocity_y)


# Calculate average angular velocity
angular_velocity = [i[1] for i in dataset_to_vel]
average_angular_velocity = statistics.mean(angular_velocity)



#############################################################################################################


#     c) Conociendo la posición y orientación inicial del robot,
#        reconstruir la trayectoria aplicando las velocidades
#        anteriormente calculadas, y determinar el error que
#        se comete en los siguientes supuestos:

#              c1 sin error en las velocidades

#              c2 añadiendo a la velocidad lineal un error gaussiano de media nula y    
#                desviación típica igual al 1% de la media de la velocidad lineal 
#               (velocidad angular sin ruido)

#               c3 añadiendo a la velocidad angular un error gaussiano de media nula
#                y desviación típica igual al 1% de la media del valor absoluto de la 
#                   velocidad angular (velocidad lineal sin ruido).



# c1
# calculating coordinates generated by velocities without ERROR

def unit_vector(vector):
    magnitude = np.linalg.norm(vector)
    
    # Avoid division by zero
    if magnitude == 0:
        return vector
    
    unit_vector = vector / magnitude
    return unit_vector

def rotate_vector(coordinates, angle):
  (x,y) = coordinates
  new_x = x * math.cos(angle) - y * math.sin(angle)
  new_y = x * math.sin(angle) + y * math.cos(angle)
  return (new_x, new_y)

def move_coordinate(initial_position, initial_direction, linear_velocity, angular_velocity, time):
    # Calculate linear displacement
    linear_displacement = linear_velocity * time

    # Update position based on linear displacement
    new_position = initial_position + linear_displacement * initial_direction

    # Update angle based on angular velocity
    theta = initial_position[1] + angular_velocity * time

    # New directional vector based on the updated angle
    new_direction = np.array([np.cos(theta), np.sin(theta)])

    return new_position, new_direction

new_dataset = [dataset[0][0:2]]

vector = np.array([dataset[1][0]-dataset[0][0], dataset[1][1]-dataset[0][1]])

for i in range(1,len(dataset_to_vel)):

    linear_distance = dataset_to_vel[i][0] * dataset_to_vel[i-1][2]
    angle_distance = dataset_to_vel[i][1] * dataset_to_vel[i-1][2]

    vector = unit_vector(rotate_vector(unit_vector(vector),angle_distance))

    new_x = new_dataset[i-1][0] + vector[0] * linear_distance
    new_y = new_dataset[i-1][1] + vector[1] * linear_distance

    new_dataset.append([new_x,new_y])




# Plotting the original data next to the new data generated with the velocities

plt.rcParams["figure.autolayout"] = True


x_coord = np.array([x[0] for x in dataset])
y_coord = np.array([y[1] for y in dataset])


fig, ax = plt.subplots()
scatter = ax.scatter(x_coord, y_coord, c=range(len(x_coord)), cmap='Reds')
ax.set_facecolor("black")



# Show the plot
plt.show()



x_coord = np.array([x[0] for x in new_dataset])
y_coord = np.array([y[1] for y in new_dataset])


fig, ax = plt.subplots()
scatter = ax.scatter(x_coord, y_coord, c=range(len(x_coord)), cmap='Reds')
ax.set_facecolor("black")



# Show the plot
plt.show()





